use crate::data_types::cred_def::CredentialDefinitionId;
use crate::data_types::rev_reg_def::RevocationRegistryDefinitionId;
use crate::data_types::schema::SchemaId;
use crate::utils::{base64, msg_pack};
use crate::Result;
use anoncreds_clsignatures::{
    AggregatedProof, CredentialSignature, RevocationRegistry, SignatureCorrectnessProof, SubProof,
    Witness,
};
use serde::de::DeserializeOwned;
use serde::Serialize;
use std::collections::HashSet;
use std::fmt::Debug;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DataIntegrityProof {
    #[serde(rename = "type")]
    pub(crate) type_: DataIntegrityProofType,
    pub(crate) cryptosuite: CryptoSuite,
    pub(crate) proof_purpose: ProofPurpose,
    pub(crate) verification_method: String,
    pub(crate) proof_value: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub(crate) challenge: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum DataIntegrityProofType {
    DataIntegrityProof,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ProofPurpose {
    #[serde(rename = "assertionMethod")]
    AssertionMethod,
    #[serde(rename = "authentication")]
    Authentication,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum CryptoSuite {
    #[serde(rename = "anoncredsvc-2023")]
    AnonCredsVc2023,
    #[serde(rename = "anoncredspresvc-2023")]
    AnonCredsPresVc2023,
    #[serde(rename = "anoncredspresvp-2023")]
    AnonCredsPresVp2023,
}

impl DataIntegrityProof {
    pub fn new<V: EncodedObject + Serialize>(
        cryptosuite: CryptoSuite,
        proof_purpose: ProofPurpose,
        verification_method: String,
        value: &V,
        challenge: Option<String>,
    ) -> Result<Self> {
        Ok(DataIntegrityProof {
            type_: DataIntegrityProofType::DataIntegrityProof,
            cryptosuite,
            proof_purpose,
            verification_method,
            proof_value: value.encode()?,
            challenge,
        })
    }

    pub(crate) fn new_credential_proof(
        value: &CredentialSignatureProofValue,
    ) -> Result<DataIntegrityProof> {
        DataIntegrityProof::new(
            CryptoSuite::AnonCredsVc2023,
            ProofPurpose::AssertionMethod,
            value.cred_def_id.to_string(),
            value,
            None,
        )
    }

    pub(crate) fn new_credential_presentation_proof(
        value: &CredentialPresentationProofValue,
    ) -> Result<DataIntegrityProof> {
        DataIntegrityProof::new(
            CryptoSuite::AnonCredsPresVc2023,
            ProofPurpose::AssertionMethod,
            value.cred_def_id.to_string(),
            value,
            None,
        )
    }

    pub(crate) fn new_presentation_proof(
        value: &PresentationProofValue,
        challenge: String,
        verification_method: String,
    ) -> Result<DataIntegrityProof> {
        DataIntegrityProof::new(
            CryptoSuite::AnonCredsPresVp2023,
            ProofPurpose::Authentication,
            verification_method,
            value,
            Some(challenge),
        )
    }

    pub fn get_proof_value<V: EncodedObject + DeserializeOwned>(&self) -> Result<V> {
        V::decode(&self.proof_value)
    }

    pub fn get_credential_signature_proof(&self) -> Result<CredentialSignatureProofValue> {
        if self.cryptosuite != CryptoSuite::AnonCredsVc2023 {
            return Err(err_msg!(
                "DataIntegrityProof does not contain {:?} proof",
                CryptoSuite::AnonCredsVc2023
            ));
        }
        if self.proof_purpose != ProofPurpose::AssertionMethod {
            return Err(err_msg!(
                "DataIntegrityProof does not contain {:?} proof",
                ProofPurpose::AssertionMethod
            ));
        }
        self.get_proof_value()
    }

    pub fn get_credential_presentation_proof(&self) -> Result<CredentialPresentationProofValue> {
        if self.cryptosuite != CryptoSuite::AnonCredsPresVc2023 {
            return Err(err_msg!(
                "DataIntegrityProof does not contain {:?} proof",
                CryptoSuite::AnonCredsVc2023
            ));
        }
        if self.proof_purpose != ProofPurpose::AssertionMethod {
            return Err(err_msg!(
                "DataIntegrityProof does not contain {:?} proof",
                ProofPurpose::AssertionMethod
            ));
        }
        self.get_proof_value()
    }

    pub fn get_presentation_proof(&self) -> Result<PresentationProofValue> {
        if self.cryptosuite != CryptoSuite::AnonCredsPresVp2023 {
            return Err(err_msg!(
                "DataIntegrityProof does not contain {:?} proof",
                CryptoSuite::AnonCredsVc2023
            ));
        }
        if self.proof_purpose != ProofPurpose::Authentication {
            return Err(err_msg!(
                "DataIntegrityProof does not contain {:?} proof",
                ProofPurpose::Authentication
            ));
        }
        self.get_proof_value()
    }

    pub fn get_credential_proof_details(&self) -> Result<CredentialProofDetails> {
        match self.cryptosuite {
            CryptoSuite::AnonCredsVc2023 => {
                let proof = self.get_credential_signature_proof()?;
                Ok(CredentialProofDetails {
                    schema_id: proof.schema_id,
                    cred_def_id: proof.cred_def_id,
                    rev_reg_id: proof.rev_reg_id,
                    rev_reg_index: proof.signature.extract_index(),
                    timestamp: None,
                })
            }
            CryptoSuite::AnonCredsPresVc2023 => {
                let proof = self.get_credential_presentation_proof()?;
                Ok(CredentialProofDetails {
                    schema_id: proof.schema_id,
                    cred_def_id: proof.cred_def_id,
                    rev_reg_id: proof.rev_reg_id,
                    rev_reg_index: None,
                    timestamp: proof.timestamp,
                })
            }
            CryptoSuite::AnonCredsPresVp2023 => Err(err_msg!("Unexpected DataIntegrityProof")),
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct CredentialSignatureProofValue {
    pub schema_id: SchemaId,
    pub cred_def_id: CredentialDefinitionId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rev_reg_id: Option<RevocationRegistryDefinitionId>,
    pub signature: CredentialSignature,
    pub signature_correctness_proof: SignatureCorrectnessProof,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rev_reg: Option<RevocationRegistry>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub witness: Option<Witness>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CredentialPresentationProofValue {
    pub schema_id: SchemaId,
    pub cred_def_id: CredentialDefinitionId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rev_reg_id: Option<RevocationRegistryDefinitionId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<u64>,
    pub mapping: CredentialAttributesMapping,
    pub sub_proof: SubProof,
}

#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CredentialAttributesMapping {
    #[serde(default)]
    pub revealed_attributes: HashSet<String>,
    pub revealed_attribute_groups: HashSet<String>,
    #[serde(default)]
    pub unrevealed_attributes: HashSet<String>,
    #[serde(default)]
    pub predicates: HashSet<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PresentationProofValue {
    pub aggregated: AggregatedProof,
}

impl EncodedObject for CredentialSignatureProofValue {}

impl EncodedObject for CredentialPresentationProofValue {}

impl EncodedObject for PresentationProofValue {}

// Credential information aggregated from `CredentialSignatureProof` and `CredentialPresentationProofValue`
// This information is needed for presentation creation and verification
#[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]
pub struct CredentialProofDetails {
    pub schema_id: SchemaId,
    pub cred_def_id: CredentialDefinitionId,
    pub rev_reg_id: Option<RevocationRegistryDefinitionId>,
    pub rev_reg_index: Option<u32>,
    pub timestamp: Option<u64>,
}

const BASE_HEADER: char = 'u';

pub trait EncodedObject {
    fn encode(&self) -> Result<String>
    where
        Self: Serialize,
    {
        let msg_pack_encoded = msg_pack::encode(self)?;
        let base64_encoded = base64::encode(msg_pack_encoded);
        Ok(format!("{}{}", BASE_HEADER, base64_encoded))
    }

    fn decode(string: &str) -> Result<Self>
    where
        Self: DeserializeOwned,
    {
        match string.chars().next() {
            Some(BASE_HEADER) => {
                // ok
            }
            value => return Err(err_msg!("Unexpected multibase base header {:?}", value)),
        }
        let decoded = base64::decode(&string[1..])?;
        let obj: Self = msg_pack::decode(&decoded)?;
        Ok(obj)
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;
    use crate::services::w3c::verifier;
    use crate::w3c::credential_conversion::tests::{cred_def_id, schema_id};
    use rstest::*;

    pub(crate) const PROOF_TIMESTAMP: u64 = 50;

    pub(crate) fn cl_credential_signature() -> CredentialSignature {
        // clsignatures library does not provide a function to either get default or construct signature
        serde_json::from_value(json!({
            "p_credential": {
                "m_2": "57832835556928742723946725004638238236382427793876617639158517726445069815397",
                "a": "20335594316731334597758816443885619716281946894071547670112874227353349613733788033617671091848119624077343554670947282810485774124636153228333825818186760397527729892806528284243491342499262911619541896964620427749043381625203893661466943880747122017539322865930800203806065857795584699623987557173946111100450130555197585324032975907705976283592876161733661021481170756352943172201881541765527633833412431874555779986196454199886878078859992928382512010526711165717317294021035408585595567390933051546616905350933492259317172537982279278238456869493798937355032304448696707549688520575565393297998400926856935054785",
                "e": "259344723055062059907025491480697571938277889515152306249728583105665800713306759149981690559193987143012367913206299323899696942213235956742930114221280625468933785621106476195767",
                "v": "6264315754962089362691677910875768714719628097173834826942639456162861264780209679632476338104728648674666095282910717315628966174111516324733617604883927936031834134944562245348356595475949760140820205017843765225176947252534891385340037654527825604373031641665762232119470199172203915071879260274922482308419475927587898260844045340005759709509719230224917577081434498505999519246994431019808643717455525020238858900077950802493426663298211783820016830018445034267920428147219321200498121844471986156393710041532347890155773933440967485292509669092990420513062430659637641764166558511575862600071368439136343180394499313466692464923385392375334511727761876368691568580574716011747008456027092663180661749027223129454567715456876258225945998241007751462618767907499044716919115655029979467845162863204339002632523083819"
            }
        })).unwrap()
    }

    pub(crate) fn cl_credential_signature_correctness_proof() -> SignatureCorrectnessProof {
        // clsignatures library does not provide a function to either get default or construct signature correctness proof
        serde_json::from_value(json!({
            "se": "16380378819766384687299800964395104347426132415600670073499502988403571039552426989440730562439872799389359320216622430122149635890650280073919616970308875713611769602805907315796100888051513191790990723115153015179238215201014858697020476301190889292739142646098613335687696678474499610035829049097552703970387216872374849734708764603376911608392816067509505173513379900549958002287975424637744258982508227210821445545063280589183914569333870632968595659796744088289167771635644102920825749994200219186110532662348311959247565066406030309945998501282244986323336410628720691577720308242032279888024250179409222261839",
            "c": "54687071895183924055442269144489786903186459631877792294627879136747836413523"
        })).unwrap()
    }

    pub(crate) fn credential_sub_proof() -> SubProof {
        serde_json::from_value(json!({
            "primary_proof": {
                "eq_proof":{
                    "a_prime":"93850854506025106167175657367900738564840399460457583396522672546367771557204596986051012396385435450263898123125896474854176367786952154894815573554451004746144139656996044265545613968836176711502602815031392209790095794160045376494471161541029201092195175557986308757797292716881081775201092320235240062158880723682328272460090331253190919323449053508332270184449026105339413097644934519533429034485982687030017670766107427442501537423985935074367321676374406375566791092427955935956566771002472855738585522175250186544831364686282512410608147641314561395934098066750903464501612432084069923446054698174905994358631",
                    "e":"162083298053730499878539837415798033696428693449892281052193919207514842725975444071338657195491572547562439622393591965427898285748359108",
                    "m":{
                        "age":"6461691768834933403326572830814516653957231030793837560544354737855803497655300429843454445497126568685843068983890896122000977852186661939211990733462807944627807336518424313388",
                        "height":"6461691768834933403326572830814516653957231030793837560544354737855803497655300429843454445497126574195981378365198960707499125538146253636400775219219390979675126287408712407688",
                        "master_secret":"67940925789970108743024738273926421512152745397724199848594503731042154269417576665420030681245389493783225644817826683796657351721363490290016166310023507132564589104990678182299219306228446316250328302891742457726158298612477188160335451477126201081347058945471957804431939288091328124225198960258432684399",
                        "sex":"6461691768834933403326575020439114193500962122447442182375470664835531264262887123435773676729731478629261405277091910956944655533226659560277758686479462667297473396368211269136"
                    },
                    "m2":"2553030889054034879941219523536672152702359185828546810612564355745759663351165380563310203986319611277915826660660011443138240248924364893067083241825560",
                    "revealed_attrs":{
                        "name":"27034640024117331033063128044004318218486816931520886405535659934417438781507",
                        "height":"178"
                    },
                    "v":"241132863422049783305938040060597331735278274539541049316128678268379301866997158072011728743321723078574060931449243960464715113938435991871547190135480379265493203441002211218757120311064385792274455797457074741542288420192538286547871288116110058144080647854995527978708188991483561739974917309498779192480418427060775726652318167442183177955447797995160859302520108340826199956754805286213211181508112097818654928169122460464135690611512133363376553662825967455495276836834812520601471833287810311342575033448652033691127511180098524259451386027266077398672694996373787324223860522678035901333613641370426224798680813171225438770578377781015860719028452471648107174226406996348525110692233661632116547069810544117288754524961349911209241835217711929316799411645465546281445291569655422683908113895340361971530636987203042713656548617543163562701947578529101436799250628979720035967402306966520999250819096598649121167"
                },
                "ge_proofs":[
                    {
                       "alpha":"91220714671444392049098338684790704633533569564315230075539856448338492680812282072362540735427809388270066455205446617374273995782554023377399804680731177040820232234103905929245544987284390459421201350502799357084572144630393229752965186421948202493395713653211261041852571798619503895533346500039830736972086153800117378029361886647047095376275665663965834031955496258448997095624866059846872981856675389692109959092094806511454852995405728568479147049053492114956054980496971797079430191367299794264478249696184662697292162371750117069888618647245378182107893472040860186518606846123082528380203115122049346720684632822988124624232104408068871143529062290368275811065489280640284628547286984413518627275012302744149723004365305203107751097864041449256066333845275140021245574457318613498147991578104948027924350075803209003472770171508",
                       "mj":"10619618416826273180397098803657766447651768379400923597030398076034183761672856302638410567535231814845543058601785335204535280819985764784669686133824906415128411093552997221368",
                       "predicate":{
                          "attr_name":"age",
                          "p_type":"GE",
                          "value":18
                       },
                       "r":{
                          "0":"1588773841780214552359776199576628657422386379581875893884372384945078939367811669090633715735973102089830616387572913590903177855451313150803976101815197814546943692782886723295746289356733941843720702593284085499174918510800622738993820307452003642209484819110747316677067093332440085440025164455806240551962801578883036541149230246370241587135313625002361803674314220240325030115679027145118594398919147306855967972213149349618757473914836569589409360381363133999563340224289773423298061372462452654469527456288604836354940362627104777524515399631756958068413497302427594449392887094786817130374459442258515737158811686608247853699920092770291702232183843727566921363528103710173784544959052443469285368754401657196",
                          "1":"1256637461243595604322863152096695336988741930946020430733567407182983540413613586145869057743579927372473885067510018613665224897849401692855807875596945318002448112389712134976382615924445697735114266283359186511759922024528029759666589075823639433029347021711617386390388119939639554649246510017374304289842894121976296696383665849531200028223642037058012440962161711327633361506751679881935716365348597650188385003189685455873956352275864507358751108468616792212883072002977937356183984733305883101734940610235124050728483164184768583108042582305043633880442432266261059349235842130246766593025175585949268421893519917461893052466099961687152805398299274146695036237567981404300725384720284767733503300712690230066",
                          "2":"1180470752287078364045027938881431613908286199987885445191097018463514753226258434971970185913902638482837033208536492358985171746629207883670533746365587515021341605180977408566855989917724250395423339932092420398421191723451854001132891740727213359926397393866003819102156139645294868568720892107454597994399663270849626034194812335352358683129740790900198708737271280718525529045149216850592542049021883013759819845832517077594258837166386555069713745897243088088130250768210556913814239420667349881002746337249159009429446096267443703716720519147423788417467630700941214871833654279244114934863266782981572888619570061750211802733422965672862460857370701115334422790171062624083846772286688851070554099303963921104",
                          "3":"1554750004410378527983822806396206150464097753774479793235223765194888527957776464556761722575086189610621769436280902828919918551500848757948401036034758232620903277502984809681150532613764145652533551203089474969485186034939651354452101784526177955451238190690104076761670672401174038610412812526020744038000502620834777200034105678723861330359048143413197833551785458979800481541528932013012871846192835556374129289856524600042093496469951221267239541036695781151538783592366750845197652975087446697387386311902873270860149765323323187433441607423920187284116094929609221567374838533141008330348008068772941193691271050660162302081076236856953603634061067389248305683590442781682491548673677254798771710885037796659",
                          "DELTA":"1591114056356953008302389836487088294824152830750916368566265981893546977236615844801936236823422986263596737827206475075016247008711981755783323755057168890433204544347517827221359538571606352035283603183519055880349734991132973043683139771266391445623003841750375768863170117737306760487644386418014467864235824811986915610106599990309382168306174519569960373054711786607068624060933746910803303786482726306172443849393961664884433192775912375242311944208345972180566879252202193002582502332472161772185829653341558236501172811022440617874812946623249952881355038481568373284396730255846889188942800549892176796330313537049720141217138331376836082910824922102630062526235501539331525707791179105054842938922082273341"
                       },
                       "t":{
                          "0":"64866996697789195209280610141661958251568008114948414934413958296971339012889321602743229534701276778987450376839584381564432237982467665325878769345568644118005387300780740353119586313215268801420656057929003191994949238757497970606857982612190953040166976139020384044674984753007915757233780798405084657312596339298214440966181148595394143651090062868272637661599156374401948677255896118592942051029425966532644474294261068933998155420437467426800184193783489247605940353558912734022194504744614576990377832513342220548575580079569434063529465779643924541222580028865234979421406039311319392788727862833372661812079",
                          "1":"67303978424359582715108363896151264391768399044745955395288155914114263062414166017940570134013652095220132600639211498623236325803113232769613832542046971180853882781339367205952142717758262234340067056755607062165703827148360166612839585924791432604865318898396310692070583836581734207887652888544729655037417276262346412915175935713397032895503260779806300967606578152659383022978757619384247504049549400918184711168027828295536608102556236260070926784249029255670389326662927138230386472848194253812563583749887864868539756587998651377854124493763184412004468888027472328169903649172001104488180406594526088065364",
                          "2":"18436150017847362148503422934807623982558815194978492560526315168833670353679306438499002886985324139611559716808905964012901082839923805866332404521363415208828633794588913271582024302442760509341860860452135384881748467914499903893497021322668173317724455347588723088645268399003636488636255170578169602866806870175728380227213849553021449146855307562973456748083976082888488765887213872710497047213304951072622398573443877599885784967211283713595363564060299966480075439924341684314227193969890983198284879899534016462786708400323988903624076030501131051782105520306583282647892201684723226256941851600164798261880",
                          "3":"80540787074475770948660676781681004318473659262891446094891575133006197034890969100212418274423711067808416693520604223042156316702551364570788698259945859278631567782188001291620437568959698091422096339806965811163965272534011394991383654588148424651132454462060754800885777955043665365498632157797055058151411264229226312327674056428967625747209116555960361444208812300676158339558611501661414801144395602242708550065513573607276358638179403543703279653212854355283229216684185613541665048996953524052618105804915972281524980080258106845176656276743289508024830814580864628715844679439025023554817148003637660059887",
                          "DELTA":"38128302244645018703614537759663050901282421681496452389916789850297775528223375163975708479447627776714574447185672092288753220297481568686299394510463089778981483516150456298091794185362061077601863665101246931716529026964302951763043406542033213721811976816002462606153992893712899928899436878697876337417072593686060699133798221124684368093425078651290877250512092087658564967995284650495307815179709968706695989964533230783143390286689612896716897737374321292841418619819673977548636000164967688437443605065985702273593701939206841156162246473653997008652142246744504615370364717636163329586868597033790427165825"
                       },
                       "u":{
                          "0":"6426124753400912236632328522015044090086922220319370716985855652608326099686652357532800961549405711164418863901623019555846606630251161505603206034811202965910995811690795138214",
                          "1":"3909215487926900168604769541427083916058262011373000358888936014541302480601270653036273837969290381956761016976440071404509435892364951044838810885942402174245287406904366305456",
                          "2":"7652194204529394001615049073842780065526835674980893677706271902982921524392585624184469677898007893338946001313177343952762715670988112050727645115894537310867340212405807178105",
                          "3":"1041238499986953151033833015824013914006748060477385128094301887263879042479529065682677955278085858226310034138770368152097812384789680952282311296092825182415553982591317576772"
                       }
                    }
                 ]
            }
        })).unwrap()
    }

    pub(crate) fn aggregated_proof() -> AggregatedProof {
        serde_json::from_value(json!({
            "c_hash":"12021216631073704187777244636931735457451916077380601269914390379109411655797",
            "c_list":[]
        })).unwrap()
    }

    pub(crate) fn credential_signature_proof() -> CredentialSignatureProofValue {
        CredentialSignatureProofValue {
            schema_id: schema_id(),
            cred_def_id: cred_def_id(),
            rev_reg_id: None,
            signature: cl_credential_signature(),
            signature_correctness_proof: cl_credential_signature_correctness_proof(),
            rev_reg: None,
            witness: None,
        }
    }

    pub(crate) fn credential_pres_proof_value() -> CredentialPresentationProofValue {
        CredentialPresentationProofValue {
            schema_id: schema_id(),
            cred_def_id: cred_def_id(),
            rev_reg_id: Some(verifier::tests::revocation_id()),
            timestamp: Some(PROOF_TIMESTAMP),
            mapping: Default::default(),
            sub_proof: credential_sub_proof(),
        }
    }

    pub(crate) fn presentation_proof_value() -> PresentationProofValue {
        PresentationProofValue {
            aggregated: aggregated_proof(),
        }
    }

    #[derive(Debug, PartialEq, Serialize, Deserialize)]
    struct TestObject {
        type_: String,
        value: i32,
    }

    impl EncodedObject for TestObject {}

    #[test]
    fn encoded_object_encode_decode_works() {
        let obj = TestObject {
            type_: "Test".to_string(),
            value: 1,
        };
        let encoded = obj.encode().unwrap();
        assert_eq!("ugqV0eXBlX6RUZXN0pXZhbHVlAQ", encoded);
        let decoded = TestObject::decode(&encoded).unwrap();
        assert_eq!(obj, decoded)
    }

    fn credential_proof() -> DataIntegrityProof {
        let credential_proof = credential_signature_proof();
        DataIntegrityProof::new_credential_proof(&credential_proof).unwrap()
    }

    fn credential_pres_proof() -> DataIntegrityProof {
        let credential_pres_proof = credential_pres_proof_value();
        DataIntegrityProof::new_credential_presentation_proof(&credential_pres_proof).unwrap()
    }

    fn presentation_proof() -> DataIntegrityProof {
        let presentation_proof = presentation_proof_value();
        DataIntegrityProof::new_presentation_proof(
            &presentation_proof,
            "1".to_string(),
            cred_def_id().to_string(),
        )
        .unwrap()
    }

    #[rstest]
    #[case(
        credential_proof(),
        ProofPurpose::AssertionMethod,
        CryptoSuite::AnonCredsVc2023
    )]
    #[case(
        credential_pres_proof(),
        ProofPurpose::AssertionMethod,
        CryptoSuite::AnonCredsPresVc2023
    )]
    #[case(
        presentation_proof(),
        ProofPurpose::Authentication,
        CryptoSuite::AnonCredsPresVp2023
    )]
    fn create_poof_cases(
        #[case] proof: DataIntegrityProof,
        #[case] purpose: ProofPurpose,
        #[case] suite: CryptoSuite,
    ) {
        assert_eq!(DataIntegrityProofType::DataIntegrityProof, proof.type_);
        assert_eq!(purpose, proof.proof_purpose);
        assert_eq!(suite, proof.cryptosuite);
        assert_eq!(cred_def_id().to_string(), proof.verification_method);
    }

    #[rstest]
    #[case(credential_proof(), true, false, false)]
    #[case(credential_pres_proof(), false, true, false)]
    #[case(presentation_proof(), false, false, true)]
    fn get_poof_value_cases(
        #[case] proof: DataIntegrityProof,
        #[case] is_credential_signature_proof: bool,
        #[case] is_credential_presentation_proof: bool,
        #[case] is_presentation_proof: bool,
    ) {
        assert_eq!(
            is_credential_signature_proof,
            proof.get_credential_signature_proof().is_ok()
        );
        assert_eq!(
            is_credential_presentation_proof,
            proof.get_credential_presentation_proof().is_ok()
        );
        assert_eq!(
            is_presentation_proof,
            proof.get_presentation_proof().is_ok()
        );
    }
}
